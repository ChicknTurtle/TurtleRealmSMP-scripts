
import:
    java.lang.String as javaString
    java.awt.Color as javaColor
    net.kyori.adventure.text.format.NamedTextColor

function hexToDecimal(hex:string) :: number:
    if first character of {_hex} is "#":
        set {_hex} to (substring of {_hex} from index 2 to index (length of {_hex}))
    set {_hex} to uppercase {_hex}
    set {_chars} to "0123456789ABCDEF"
    set {_rHi} to (first index of (character at 1 of {_hex}) in {_chars}) - 1
    set {_rLo} to (first index of (character at 2 of {_hex}) in {_chars}) - 1
    set {_gHi} to (first index of (character at 3 of {_hex}) in {_chars}) - 1
    set {_gLo} to (first index of (character at 4 of {_hex}) in {_chars}) - 1
    set {_bHi} to (first index of (character at 5 of {_hex}) in {_chars}) - 1
    set {_bLo} to (first index of (character at 6 of {_hex}) in {_chars}) - 1
    set {_r} to ({_rHi} * 16 + {_rLo})
    set {_g} to ({_gHi} * 16 + {_gLo})
    set {_b} to ({_bHi} * 16 + {_bLo})
    set {_result} to ({_r} * 65536 + {_g} * 256 + {_b})
    return {_result}

function decimalToHex(n:number) :: string:
    if {_n} < 0:
        add 4294967296 to {_n}
    set {_r} to (bits 16-23 of {_n})
    set {_g} to (bits 8-15 of {_n})
    set {_b} to (bits 0-7 of {_n})
    set {_hexchars} to "0123456789ABCDEF"
    set {_result} to "%(character at ((bits 4-7 of {_r}) + 1) in {_hexchars})%%(character at ((bits 0-3 of {_r}) + 1) in {_hexchars})%"
    set {_result} to "%{_result}%%(character at ((bits 4-7 of {_g}) + 1) in {_hexchars})%%(character at ((bits 0-3 of {_g}) + 1) in {_hexchars})%"
    set {_result} to "%{_result}%%(character at ((bits 4-7 of {_b}) + 1) in {_hexchars})%%(character at ((bits 0-3 of {_b}) + 1) in {_hexchars})%"
    return {_result}

function decimalToColor(n:number) :: color:
    if {_n} < 0:
        add 4294967296 to {_n}
    set {_r} to (bits 16-23 of {_n})
    set {_g} to (bits 8-15 of {_n})
    set {_b} to (bits 0-7 of {_n})
    return rgb({_r}, {_g}, {_b})

function rgbToHex(r:integer, g:integer, b:integer) :: string:
    return javaString.format("#%%02X%%02X%%02X", [{_r},{_g},{_b}])

function colorToHex(col:color) :: string:
    set {_r} to (red value of {_col})
    set {_g} to (green value of {_col})
    set {_b} to (blue value of {_col})
    return javaString.format("#%%02X%%02X%%02X", [{_r},{_g},{_b}])

function hexToColor(hex:string) :: color:
    set {_c} to javaColor.decode({_hex})
    return rgb({_c}.getRed(),{_c}.getGreen(),{_c}.getBlue())

function randomHexCode() :: string:
    set {_chars::*} to "0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"
    loop 6 times:
        add (random element of {_chars::*}) to {_code::*}
    return "#%join {_code::*}%"

function colorObjectToColor(col:object) :: color:
    return rgb({_col}.red(), {_col}.green(), {_col}.blue())

# color code to color
# e.g. "§d" > light purple
function colorCodeToColor(code:string) :: color:
    if {_code} starts with "§":
        set {_code} to (character at 2 of {_code})
    else if {_code} starts with "&":
        set {_code} to (character at 2 of {_code})
    if {_code} is "0":
        return colorObjectToColor(NamedTextColor.BLACK)
    else if {_code} is "1":
        return colorObjectToColor(NamedTextColor.DARK_BLUE)
    else if {_code} is "2":
        return colorObjectToColor(NamedTextColor.DARK_GREEN)
    else if {_code} is "3":
        return colorObjectToColor(NamedTextColor.DARK_AQUA)
    else if {_code} is "4":
        return colorObjectToColor(NamedTextColor.DARK_RED)
    else if {_code} is "5":
        return colorObjectToColor(NamedTextColor.DARK_PURPLE)
    else if {_code} is "6":
        return colorObjectToColor(NamedTextColor.GOLD)
    else if {_code} is "7":
        return colorObjectToColor(NamedTextColor.GRAY)
    else if {_code} is "8":
        return colorObjectToColor(NamedTextColor.DARK_GRAY)
    else if {_code} is "9":
        return colorObjectToColor(NamedTextColor.BLUE)
    else if {_code} is "a":
        return colorObjectToColor(NamedTextColor.GREEN)
    else if {_code} is "b":
        return colorObjectToColor(NamedTextColor.AQUA)
    else if {_code} is "c":
        return colorObjectToColor(NamedTextColor.RED)
    else if {_code} is "d":
        return colorObjectToColor(NamedTextColor.LIGHT_PURPLE)
    else if {_code} is "e":
        return colorObjectToColor(NamedTextColor.YELLOW)
    else if {_code} is "f":
        return colorObjectToColor(NamedTextColor.WHITE)
    return colorObjectToColor(NamedTextColor.WHITE)


# color to color code
# e.g. light purple > "§d"
function colorToColorCode(color:color) :: string:
    if {_color} is colorObjectToColor(NamedTextColor.BLACK):
        return "§0"
    else if {_color} is colorObjectToColor(NamedTextColor.DARK_BLUE):
        return "§1"
    else if {_color} is colorObjectToColor(NamedTextColor.DARK_GREEN):
        return "§2"
    else if {_color} is colorObjectToColor(NamedTextColor.DARK_AQUA):
        return "§3"
    else if {_color} is colorObjectToColor(NamedTextColor.DARK_RED):
        return "§4"
    else if {_color} is colorObjectToColor(NamedTextColor.DARK_PURPLE):
        return "§5"
    else if {_color} is colorObjectToColor(NamedTextColor.GOLD):
        return "§6"
    else if {_color} is colorObjectToColor(NamedTextColor.GRAY):
        return "§7"
    else if {_color} is colorObjectToColor(NamedTextColor.DARK_GRAY):
        return "§8"
    else if {_color} is colorObjectToColor(NamedTextColor.BLUE):
        return "§9"
    else if {_color} is colorObjectToColor(NamedTextColor.GREEN):
        return "§a"
    else if {_color} is colorObjectToColor(NamedTextColor.AQUA):
        return "§b"
    else if {_color} is colorObjectToColor(NamedTextColor.RED):
        return "§c"
    else if {_color} is colorObjectToColor(NamedTextColor.LIGHT_PURPLE):
        return "§d"
    else if {_color} is colorObjectToColor(NamedTextColor.YELLOW):
        return "§e"
    else if {_color} is colorObjectToColor(NamedTextColor.WHITE):
        return "§f"
    return "§f"

# color to dye color str
# e.g. light green > "lime"
function colorToDyeColor(color:color) :: string:
    if {_color} is gray:
        return "light_gray"
    else if {_color} is dark gray:
        return "gray"
    else if {_color} is light green:
        return "lime"
    else if {_color} is light cyan:
        return "light_blue"
    return "%{_color}%"

# dye color str to color
function dyeColorToColor(color:string) :: color:
    if {_color} is "gray":
        return dark gray
    replace "_" with " " in {_color}
    return {_color} parsed as color

# item to its color str
function dyeColorOf(item:item) :: string:
    set {_id} to (last element of ((item id of {_item}) split at ":"))
    set {_colors::*} to "black", "white", "light_gray", "gray", "brown", "red", "orange", "yellow", "lime", "green", "cyan", "light_blue", "blue", "purple", "magenta", "pink"
    sort {_colors::*} by length of input
    loop {_colors::*}:
        if {_id} is loop-value:
            return loop-value
        if {_id} starts with "%loop-value%_":
            return loop-value

# Ping color
# Get a color based on the ping value
# Based on functionality from Better Ping Display mod
expression:
    patterns:
        ping color (of|from) %integer%
        %integer%'s ping color
    get:
        set {_ping} to expr-1
        set {_PING_START} to 0
        set {_PING_MID} to 150
        set {_PING_END} to 300

        set {_COLOR_GREY} to rgb(83, 83, 83)
        set {_COLOR_START} to rgb(0, 230, 118)
        set {_COLOR_MID} to rgb(214, 205, 48)
        set {_COLOR_END} to rgb(229, 57, 53)

        if ({_ping} < {_PING_START}):
            return {_COLOR_GREY}
        else if ({_ping} < {_PING_MID}):
            return interpolate({_COLOR_START}, {_COLOR_MID}, computeOffset({_PING_START}, {_PING_MID}, {_ping}))
        else:
            return interpolate({_COLOR_MID}, {_COLOR_END}, computeOffset({_PING_MID}, {_PING_END}, min({_ping}, {_PING_END})))

local function computeOffset(start:integer, end:integer, value:integer) :: number:
    set {_offset} to ({_value}-{_start}) / ({_end}-{_start})
    return clamp({_offset}, 0, 1)

local function interpolate(color1:color, color2:color, offset:number) :: color:
    set {_r} to ({_color1}.getRed() + ({_color2}.getRed() - {_color1}.getRed()) * {_offset})
    set {_g} to ({_color1}.getGreen() + ({_color2}.getGreen() - {_color1}.getGreen()) * {_offset})
    set {_b} to ({_color1}.getBlue() + ({_color2}.getBlue() - {_color1}.getBlue()) * {_offset})
    return rgb({_r}, {_g}, {_b})
