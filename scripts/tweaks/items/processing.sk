
import:
    org.bukkit.block.BlockSupport

options:
    pressingRequiresObsidian: true

on load:
    clear {-pressingRecipes::*}

struct play_sound:
    id: string
    volume: number=1
    pitch: number=1
local function makeSoundStruct(id:string, volume:number=1, pitch:number=1) :: struct:
    return play_sound struct:
        id: {_id}
        volume: {_volume}
        pitch: {_pitch}
local function defaultSound() :: struct:
    return makeSoundStruct("minecraft:block.stone.break")

struct pressing_recipe_result:
    item: string
    count: integer=1
    chance: number=1
struct pressing_recipe:
    input: string
    results: structs
    sound: struct=defaultSound()

local function getCompactedItem(item:itemtype,amount:integer) :: objects:
    if {_amount} < 4:
        return {_}
    set {_3x3} to (crafting result of ({_item},{_item},{_item},{_item},{_item},{_item},{_item},{_item},{_item}))
    if {_3x3} is set:
        {_amount} >= 9
        return {_3x3} and 9
    set {_2x2} to (crafting result of ({_item},{_item},{_item},{_item}))
    if {_2x2} is set:
        {_amount} >= 4
        return {_2x2} and 4

# anvil crush items
on entity change block:
    event-entity is falling block
    (block tag "minecraft:anvil") contains event-blockdata
    pressProcessBlock(event-block, vector of down)

# piston crush items
on piston extend:
    (size of ...event.getBlocks()) is 0
    set {_b} to (block in front of event-block)
    set {_b2} to (block 2 blocks in front of event-block)
    set {_face} to {_b2}.getFace({_b})
    (blockdata of {_b2}).isFaceSturdy({_face}, BlockSupport.FULL)
    if any:
        {@pressingRequiresObsidian} is false
        block tag "minecraft:needs_diamond_tool" contains {_b2}
    then:
        pressProcessBlock({_b}, {_face}.getOppositeFace().getDirection())

function pressProcessBlock(b:block, dir:vector):
    set {_e::*} to (entities within {_b} where [input is a dropped item])
    size of {_e::*} > 0
    set {_crusher} to (block at {_b} ~ {_dir})
    if (block under {_crusher}) is hopper:
        set {_hopper} to (block under {_crusher})
    loop {_e::*}:
        if true is true:
            # check recipes
            loop {-pressingRecipes::*}:
                set {_input} to (loop-value-2's input field)
                replace "#" with "" in {_input}
                if all:
                    {_input} isn't getId(item of loop-value-1)
                    (raw name of tag values of item tag {_input}) doesn't contain getId(item of loop-value-1)
                then:
                    continue
                loop (loop-value-2's results field):
                    chance of (loop-value-3's chance field)
                    loop (loop-value-3's count field) times:
                        add getItem(loop-value-3's item field) to {_spawnitems::*}
                add (loop-value-2's sound field) to {_playsounds::*}
                add use remainder of (item of loop-value-1) to {_spawnitems::*}
                make 10 of item particle using (type of item of loop-value-1) at loop-value-1 with extra 0.2
                loop-value-1.setItemStack(loop-value-1.getItemStack().subtract())
                set (short tag "Age" of nbt of loop-value-1) to 0
                exit 2 sections
            # check packing
            set {_compacted::*} to getCompactedItem((item of loop-value-1), (item amount of (item of loop-value-1)))
            {_compacted::*} is set
            set {_compacted} to {_compacted::1}
            set {_compactedAmount} to {_compacted::2}
            add {_compacted} to {_spawnitems::*}
            loop {_compactedAmount} times:
                add use remainder of (item of loop-value-1) to {_spawnitems::*}
            make 10 of item particle using (type of item of loop-value-1) at loop-value-1 with extra 0.2
            loop-value.setItemStack(loop-value.getItemStack().subtract({_compactedAmount}))
            set (short tag "Age" of nbt of loop-value-1) to 0
        {_spawnitems::*} is set
        set {_somethingspawned} to true
        loop {_spawnitems::*}:
            # drop or put in hopper
            if all:
                {_hopper} is set
                blockdata tag "enabled" of (blockdata of {_hopper}) is true
                (inventory of {_hopper}) has space for loop-value-2
            then:
                add loop-value-2 to inventory of {_hopper}
            else:
                drop 1 of loop-value-2 at loop-value-1 without velocity
            make 10 of item particle using (type of loop-value-2) at loop-value-1 with extra 0.2
        clear {_spawnitems::*}
    if {_somethingspawned} is true:
        play sound "minecraft:entity.zombie.attack_wooden_door" with volume 0.5 with pitch 2 at {_b}
    loop {_playsounds::*}:
        set {_id} to (loop-value-1's id field)
        {_alreadyplayed::*} doesn't contain {_id}
        play sound {_id} with volume (loop-value-1's volume field) with pitch (loop-value-1's pitch field) at {_b}
        add {_id} to {_alreadyplayed::*}
    clear {_playsounds::*}
    clear {_alreadyplayed::*}
