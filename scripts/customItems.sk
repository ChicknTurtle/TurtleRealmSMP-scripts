using reflection

import:
    org.bukkit.Bukkit
    ch.njol.skript.Skript

on skript start:
    wait 1 tick
    loadCustomItems()
    loadAllRecipes()
local function loadCustomItems():
    clear {-customItems::*}
    log info "â€ðŸ”¥ Loading custom items..."
    call custom event "registerCustomItems"
    set {_s} to "" if (size of (indexes of {-customItems::*}) is 1) else "s"
    log info "Loaded &b%size of (indexes of {-customItems::*})% &rcustom item%{_s}%."
local function loadAllRecipes():
    log info "ðŸ› ï¸  Loading server recipes..."
    Bukkit.resetRecipes()
    set {_vanilla} to (size of all recipes)
    call custom event "registerCustomRecipes"
    unlock recipes (all recipes) for (all players)
    update server recipes
    set {_custom} to ((size of all recipes)-{_vanilla})
    set {_s} to "" if ({_custom} is 1) else "s"
    log info "Loaded &b%{_vanilla}% Â§rdefault and Â§b%{_custom}% &rcustom recipe%{_s}%."

# Get/set/delete a custom item
expression:
    return type: itemtype
    patterns:
        [the] (custom item|ci) [with id|named] %string/namespacedkey%
    get:
        set {_id} to (expr-1 if (expr-1 is namespacedkey) else (namespaced key from expr-1))
        {_id} is set
        if {-customItems::%{_id}%::item} isn't set:
            return (itemtype from key {_id})
        return {-customItems::%{_id}%::item}
    set:
        set {_item} to (change value)
        {_item} isn't air
        {_item} is instance of itemtype
        set {_id} to (expr-1 if (expr-1 is namespacedkey) else (namespaced key from expr-1))
        {_id} is set
        set (item id of {_item}) to {_id}
        set {-customItems::%{_id}%::item} to (updated {_item})
    delete:
        set {_id} to (expr-1 if (expr-1 is namespacedkey) else (namespaced key from expr-1))
        {_id} is set
        delete {-customItems::%{_id}%::*}

# Register a custom item (alias)
effect:
    patterns:
        register [custom] item %itemtype% as %string/namespacedkey%
        register %itemtype% as [custom] item %string/namespacedkey%
    trigger:
        set (custom item expr-2) to expr-1

# Get all custom items
plural expression:
    return type: itemtype
    loop of: item
    patterns:
        all [[of] the] [registered|defined|loaded] custom items
    get:
        return (indexes of {-customItems::*}) mapped with [{-customItems::%input%::item}]

# Get/set/delete the custom id of an item
itemtype property item id:
    return type: string
    get:
        set {_id} to (string tag "customItems;id" of (custom nbt of expr-1))
        return {_id} ? (raw name of expr-1)
    set:
        set {_item} to expr-1
        set (string tag "customItems;id" of (custom nbt of {_item})) to "%change value%"
        set (raw expression of expr-1) to {_item}
    delete:
        set {_item} to expr-1
        delete (string tag "customItems;id" of (custom nbt of {_item}))
        set (raw expression of expr-1) to {_item}

# Get/set/delete the update function of a custom item
string property update function:
    return type: function
    get:
        return {-customItems::%expr-1%::updateFunction}
    set:
        change value is a function
        set {-customItems::%expr-1%::updateFunction} to change value
    delete:
        delete {-customItems::%expr-1%::updateFunction}

# Update an item based on its custom id
expression:
    patterns:
        updated [[custom] item] %itemtype%
    get:
        set {_item} to expr-1
        if {_item} ? air is air:
            return {_item}
        set {_original} to {_item}
        # update legacy custom items
        if (string tag "customId" of (custom nbt of {_item})) is set:
            set (string tag "customItems;id" of (custom nbt of {_item})) to (string tag "customId" of (custom nbt of {_item}))
            delete (string tag "customId" of (custom nbt of {_item}))
        # update nbt
        set {_id} to (item id of {_item})
        set {_rawitem} to (custom item {_id}) ? {_item}
        if (int tag "minecraft:damage" of (nbt of {_item})) is 0:
            (int tag "minecraft:max_damage" of (vanilla nbt of {_rawitem})) isn't set
            delete (int tag "minecraft:damage" of (nbt of {_item}))
        set {_newitem} to (item amount of {_item}) of (type of {_rawitem})
        add nbt of {_item} to nbt of {_newitem}
        add nbt of {_rawitem} to nbt of {_newitem}
        # call update function
        if {-customItems::%{_id}%::updateFunction} is set:
            set {_newitem} to (result of {-customItems::%{_id}%::updateFunction} with args {_newitem}) ? {_newitem}
        # call event
        set {_eventValues::item} to {_item}
        set {_eventValues::string} to {_id}
        set {_event} to (custom event "customItemUpdate" using event-values {_eventValues::*})
        call {_event}
        if {_event} is cancelled:
            return {_original}
        return {_newitem}
effect:
    patterns:
        update [[custom] item] %itemtype%
    trigger:
        set (raw expression of expr-1) to (updated expr-1)

# Add custom interact nbt to an item
effect:
    patterns:
        add custom interact[ion] [nbt] to %itemtype%
        set custom interact[ion] of %itemtype% to (true|on|enabled)
    trigger:
        set {_item} to expr-1
        set (compound tag "minecraft:consumable" of (nbt of {_item})) to (nbt compound from "{consume_seconds:0.05,animation:""none"",sound:{sound_id:""""},has_consume_particles:false,on_consume_effects:[{type:""minecraft:play_sound"",sound:{sound_id:""""}}]}")
        apply food component to {_item}:
            nutrition: 0
            saturation: 0
            can_always_eat: true
        set (boolean tag "customItems;hasCustomInteract" of (custom nbt of {_item})) to true
        set raw expression of expr-1 to {_item}

# Remove custom interact nbt from an item
effect:
    patterns:
        remove custom interact[ion] [nbt] from %itemtype%
        set custom interact[ion] of %itemtype% to (false|off|disabled)
    trigger:
        set {_item} to expr-1
        delete (compound tag "minecraft:consumable" of (nbt of {_item}))
        delete (compound tag "minecraft:food" of (nbt of {_item}))
        delete (boolean tag "customItems;hasCustomInteract" of (custom nbt of {_item}))
        set raw expression of expr-1 to {_item}

# Custom interact behavior
on consume with priority lowest:
    set {_item} to event-item
    (boolean tag "customItems;hasCustomInteract" of (custom nbt of {_item})) is true
    cancel event
    set event-item to {_item}
    try player.setCooldown(event-item, floor(20*(float tag "minecraft:use_cooldown;seconds" of nbt of event-item)))
    set {_eventValues::player} to event-player
    set {_eventValues::item} to event-item
    set {_eventValues::world} to event-world
    set {_eventValues::string} to (item id of event-item)
    set {_eventValues::equipmentslot} to event.getHand()
    call custom event "customItemInteract" using event-values {_eventValues::*}

# Custom repair items
plural expression:
    patterns:
        custom repair[able] (item|material)s of %itemtype%
        %itemtype%'s custom repair[able] (item|material)s
    return type: itemtypes
    get:
        return (string list tag "customItems;repairItems" of (custom nbt of (expr-1))) mapped with [custom item input]
    set:
        set {_item} to expr-1
        set (repairable items of {_item}) to (change values)
        set (string list tag "customItems;repairItems" of (custom nbt of {_item})) to (item id of change values)
        set (raw expression of expr-1) to {_item}

# Custom allowed enchants
plural expression:
    patterns:
        (allowed|valid) enchant[ment]s of %itemtype%
        %itemtype%'s (allowed|valid) enchant[ment]s
    return type: enchantments
    get:
        return (string list tag "customItems;allowedEnchantments" of (custom nbt of (expr-1))) mapped with [enchantment from key input]
    set:
        set {_item} to expr-1
        set (string list tag "customItems;allowedEnchantments" of (custom nbt of {_item})) to ((change values) mapped with ["%namespaced key of input%"])
        set (raw expression of expr-1) to {_item}

# Custom items command
brig command tree /turtle:customitems:
    permission: op
    aliases: ci
    literal arg "give":
        players arg "players":
            namespacedkey arg "item":
                suggestions:
                    apply suggestion (indexes of {-customItems::*})
                optional int arg "count" with min 1 and max 6400:
                    trigger:
                        set {_id} to {_item} ? ""
                        set {_count} to {_count} ? 1
                        if {-customItems::%{_id}%::item} isn't set:
                            send "Â§cUnknown custom item '%{_id}%'" to command sender
                            stop
                        set {_customItem} to {-customItems::%{_id}%::item}
                        give or drop {_count} of {_customItem} to {_players::*}
                        set {_c::1} to (text component from "Gave %{_count}% ")
                        set {_c::2} to (item chat component of {_customItem})
                        set {_c::3} to (text component from " to ")
                        if (size of {_players::*}) > 1:
                            set {_c::4} to (text component from "%size of {_players::*}% players")
                        else:
                            set {_c::4} to playerComponent(first element of {_players::*})
                        send components (merge components {_c::*}) to command sender
    literal arg "reload":
        literal arg "items":
            trigger:
                send "Â§fReloading all custom items..." to command sender
                loadCustomItems()
                send "Â§aFinished reloading custom items!" to command sender
        literal arg "recipes":
            trigger:
                send "Â§fReloading all recipes..." to command sender
                loadAllRecipes()
                send "Â§aFinished reloading recipes!" to command sender
        literal arg "all":
            trigger:
                send "Â§fReloading all custom items and recipes..." to command sender
                loadCustomItems()
                send "Â§bFinished reloading custom items..." to command sender
                loadAllRecipes()
                send "Â§aFinished reloading recipes!" to command sender
        trigger:
            send "Â§fReloading all custom items and recipes..." to command sender
            loadCustomItems()
            send "Â§bFinished reloading custom items..." to command sender
            loadAllRecipes()
            send "Â§aFinished reloading recipes!" to command sender

# update dropped items
on entity add to world:
    event-entity is a dropped item
    update item (item of event-entity)

# anvil logic
on anvil prepare:
    set {_first} to (slot 0 of event-inventory)
    set {_second} to (slot 1 of event-inventory)
    # trying to merge
    if (type of {_first}) is (type of {_second}):
        ((item id of {_first}) ? "<none>") isn't ((item id of {_second}) ? "<none>")
        # cancel if not a custom repair
        (string list tag "customItems;repairItems" of (custom nbt of {_first})) doesn't contain (item id of {_second})
        set event-slot to air
    # trying to repair
    else if (repairable items of {_first}) contains {_second}:
        set {_repairItems::*} to (string list tag "customItems;repairItems" of custom nbt of {_first}) ? (item id of (repairable items of {_first}))
        {_repairItems::*} is set
        {_repairItems::*} doesn't contain (item id of {_second})
        set event-slot to air
    # trying to apply book
    else if {_second} is enchanted book:
        set {_allowedEnchants::*} to (allowed enchants of {_first})
        loop (stored enchantments of {_second}):
            {_allowedEnchants::*} contains (type of loop-value)
            (enchantment level of loop-value) > ((level of (type of loop-value) of event-slot) ? 0)
            add loop-value to {_enchants::*}
        {_enchants::*} is set
        if event-slot is air:
            set event-slot to {_first}
            set (name of event-slot) to colored (anvil text input of event-inventory)
        enchant event-slot with {_enchants::*}
    update event-slot

# player joining
on join:
    loop 41 times:
        update (slot (loop-iteration)-1 of player)

# /give etc
# doesn't work well when in creative
on inventory slot change:
    player's gamemode isn't creative
    event-slot isn't air
    update event-slot

# chest loot generating
on loot generate:
    loop loot:
        add (updated item loop-value) to {_newloot::*}
    set loot to {_newloot::*}

# brewing
on brew completed:
    set brewing results to (brewing results mapped with [updated input])
